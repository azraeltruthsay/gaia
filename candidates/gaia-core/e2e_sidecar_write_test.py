"""
E2E test for GAIA's natural-language write_file flow via sidecar actions.

Exercises the real pipeline that GAIA uses when it decides to write a file:
  1. EXECUTE directive parsing from LLM output
  2. SidecarAction creation
  3. MCP dispatch (gets 403 → pending approval)
  4. Human/orchestrator approval
  5. File written and verified

Usage:
    docker exec gaia-core-candidate python /app/e2e_sidecar_write_test.py
"""

import json
import logging
import os
import re
import sys
import time

logging.disable(logging.WARNING)


def main() -> int:
    passed = 0
    failed = 0

    def check(label: str, condition: bool, detail: str = ""):
        nonlocal passed, failed
        if condition:
            passed += 1
            print(f"  PASS  {label}")
        else:
            failed += 1
            print(f"  FAIL  {label}{f': {detail}' if detail else ''}")

    print("=" * 60)
    print("Sidecar write_file — E2E Natural Language Flow")
    print("=" * 60)

    # --- 1. Imports ---
    print("\n--- Imports ---")
    try:
        from gaia_core.utils import mcp_client
        from gaia_core.cognition.cognition_packet import SidecarAction
        from gaia_core.config import Config
        check("Imports", True)
    except Exception as e:
        check("Imports", False, str(e))
        return 1

    # --- 2. Parse EXECUTE directive from simulated LLM output ---
    print("\n--- EXECUTE Parsing ---")
    test_path = "/knowledge/self_generated_docs/e2e_sidecar_test.md"
    test_content = f"""---
symbol: E2E_SIDECAR_TEST
title: RAG Architecture Documentation (E2E Test)
tags:
  - test
  - e2e
  - rag
version: v1.0
scope: project
---

# RAG Architecture

This document was generated by the E2E sidecar write test at {time.strftime('%Y-%m-%d %H:%M:%S')}.

## Overview
The RAG system uses a sliding window of 6 recent messages plus semantic retrieval
of older conversation history via all-MiniLM-L6-v2 embeddings.
"""

    # Simulate LLM output with an EXECUTE directive (exactly as the LLM would produce)
    llm_output = f"""RESPONSE: I'll document the RAG architecture for you.

EXECUTE: write_file {json.dumps({"path": test_path, "content": test_content})}"""

    # Parse EXECUTE directives — same regex used by output_router._parse_llm_output_into_packet
    execute_matches = re.findall(r"EXECUTE:\s*(.*)", llm_output)
    check("EXECUTE directive found", len(execute_matches) == 1,
          f"found {len(execute_matches)}")

    sidecar_actions = []
    for cmd_str in execute_matches:
        parts = cmd_str.strip().split(None, 1)
        action_type = parts[0]
        raw_args = parts[1] if len(parts) > 1 else ""
        params = {}
        if raw_args.lstrip().startswith("{"):
            try:
                params = json.loads(raw_args)
            except json.JSONDecodeError:
                params = {"command": raw_args}
        else:
            params = {"command": raw_args} if raw_args else {}
        sidecar_actions.append(SidecarAction(action_type=action_type, params=params))

    check("SidecarAction created", len(sidecar_actions) == 1,
          f"got {len(sidecar_actions)}")
    if sidecar_actions:
        action = sidecar_actions[0]
        check("Action type is write_file", action.action_type == "write_file",
              f"got {action.action_type}")
        check("Action has correct path", action.params.get("path") == test_path)
        check("Action has content", bool(action.params.get("content")))

    # --- 3. MCP dispatch (403 → pending approval) ---
    print("\n--- MCP Dispatch (403 Gate) ---")

    action = sidecar_actions[0]
    endpoint = os.getenv("MCP_ENDPOINT") or os.getenv("MCP_LITE_ENDPOINT")
    if not endpoint:
        config = Config()
        endpoint = config.constants.get("MCP_LITE_ENDPOINT", "")

    check("MCP endpoint available", bool(endpoint), f"endpoint={endpoint}")

    if not endpoint:
        return 1

    # Ensure endpoint ends with /jsonrpc
    if not endpoint.endswith("/jsonrpc"):
        if endpoint.endswith("/"):
            endpoint += "jsonrpc"
        else:
            endpoint += "/jsonrpc"

    # Call write_file directly via JSON-RPC (should get 403)
    import requests
    payload = {
        "jsonrpc": "2.0",
        "method": "write_file",
        "params": action.params,
        "id": f"e2e_sidecar_{int(time.time())}"
    }
    try:
        resp = requests.post(endpoint, json=payload, timeout=10)
        check("write_file gets 403 (SENSITIVE_TOOLS gate)", resp.status_code == 403,
              f"status={resp.status_code}")
    except Exception as e:
        check("write_file gets 403", False, str(e))
        return 1

    # Route through approval flow (same as dispatch_sidecar_actions does on 403)
    approval_req = mcp_client.request_approval_via_mcp("write_file", {
        **action.params,
        "_allow_pending": True,
    })
    check("Approval request created", approval_req.get("ok", False),
          json.dumps(approval_req)[:200])

    action_id = approval_req.get("action_id")
    challenge = approval_req.get("challenge")
    check("Got action_id", bool(action_id))
    check("Got challenge", bool(challenge))

    # --- 4. Orchestrator approval ---
    print("\n--- Orchestrator Approval ---")
    write_succeeded = False
    if action_id and challenge:
        approval_resp = mcp_client.approve_action_via_mcp(action_id, challenge[::-1])
        client_ok = approval_resp.get("ok", False)
        check("Approval submitted", client_ok, json.dumps(approval_resp)[:200])

        if client_ok:
            server_resp = approval_resp.get("result", {})
            server_ok = isinstance(server_resp, dict) and server_resp.get("ok", False)
            check("Server executed write", server_ok, json.dumps(server_resp)[:200])
            if server_ok:
                tool_result = server_resp.get("result", {})
                write_succeeded = isinstance(tool_result, dict) and tool_result.get("ok", False)
                check("write_file returned ok", write_succeeded,
                      json.dumps(tool_result)[:200])
                if write_succeeded:
                    written_bytes = tool_result.get("bytes", 0)
                    check("Bytes written > 0", written_bytes > 0,
                          f"bytes={written_bytes}")

    # --- 5. Verify file contents ---
    print("\n--- File Verification ---")
    if write_succeeded:
        read_result = mcp_client.call_jsonrpc("read_file", {"path": test_path})
        if read_result.get("ok"):
            rpc_resp = read_result.get("response", {})
            tool_data = rpc_resp.get("result", rpc_resp)
            content = tool_data.get("content", "")
            check("File readable via MCP", tool_data.get("ok", False))
            check("Has YAML front matter", "symbol: E2E_SIDECAR_TEST" in content)
            check("Has RAG documentation", "sliding window" in content.lower())
            check("Has correct title", "RAG Architecture Documentation" in content)
        else:
            for label in ["File readable via MCP", "Has YAML front matter",
                          "Has RAG documentation", "Has correct title"]:
                check(label, False, "read_file failed")
    else:
        for label in ["File readable via MCP", "Has YAML front matter",
                      "Has RAG documentation", "Has correct title"]:
            check(label, False, "write didn't succeed")

    # --- 6. Cleanup ---
    print("\n--- Cleanup ---")
    cleanup = mcp_client.request_approval_via_mcp("write_file", {
        "path": test_path, "content": "",
    })
    if cleanup.get("ok") and cleanup.get("action_id"):
        mcp_client.approve_action_via_mcp(
            cleanup["action_id"], cleanup["challenge"][::-1]
        )
    check("Test file cleaned up", True)

    # --- Summary ---
    total = passed + failed
    print(f"\n{'=' * 60}")
    print(f"{passed}/{total} checks passed")
    print(f"{'=' * 60}")
    return 1 if failed else 0


if __name__ == "__main__":
    sys.exit(main())
